<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/SecScoreDB.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/SecScoreDB.cpp" />
              <option name="originalContent" value="#include &quot;SecScoreDB.h&quot;&#10;#include &lt;iostream&gt;&#10;#include &lt;format&gt; // C++20&#10;&#10;namespace SSDB&#10;{&#10;    // ============================================================&#10;    // 构造与析构&#10;    // ============================================================&#10;&#10;    SecScoreDB::SecScoreDB(const std::filesystem::path&amp; path)&#10;        : stu_db(path / &quot;students.bin&quot;), // 使用二进制后缀&#10;          grp_db(path / &quot;groups.bin&quot;),&#10;          evt_db(path / &quot;events.bin&quot;)&#10;    {&#10;        // 一行代码完成加载！&#10;        stu = stu_db.LoadAll&lt;Student&gt;();&#10;        grp = grp_db.LoadAll&lt;Group&gt;();&#10;        evt = evt_db.LoadAll&lt;Event&gt;();&#10;&#10;        // 初始化 Event计数器&#10;        _max_event_id = 0;&#10;        for (const auto&amp; [id, _] : evt)&#10;        {&#10;            if (id &gt; _max_event_id)&#10;            {&#10;                _max_event_id = id;&#10;            }&#10;        }&#10;&#10;        // 打印日志&#10;        // std::cout &lt;&lt; &quot;Loaded &quot; &lt;&lt; stu.size() &lt;&lt; &quot; students.&quot; &lt;&lt; std::endl;&#10;    }&#10;&#10;    SecScoreDB::~SecScoreDB()&#10;    {&#10;        try&#10;        {&#10;            commit(); // 析构时自动保存&#10;        }&#10;        catch (const std::exception&amp; e)&#10;        {&#10;            // 析构函数绝对不能抛出异常，只能记录日志&#10;            std::cerr &lt;&lt; &quot;[SSDB Error] Failed to save DB on exit: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        }&#10;    }&#10;&#10;    void SecScoreDB::commit()&#10;    {&#10;        // 一行代码完成保存！&#10;        stu_db.SaveAll(stu);&#10;        grp_db.SaveAll(grp);&#10;        evt_db.SaveAll(evt);&#10;    }&#10;&#10;    // ============================================================&#10;    // Student 相关实现&#10;    // ============================================================&#10;&#10;    DynamicWrapper&lt;Student&gt; SecScoreDB::createStudent(int id)&#10;    {&#10;        if (stu.contains(id))&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Create failed: Student ID {} already exists.&quot;, id));&#10;        }&#10;&#10;        Student s;&#10;        s.SetId(id);&#10;&#10;        // 移动语义插入，高效&#10;        auto [it, success] = stu.emplace(id, std::move(s));&#10;&#10;        return DynamicWrapper&lt;Student&gt;(it-&gt;second, _stu_schema);&#10;    }&#10;&#10;    DynamicWrapper&lt;Student&gt; SecScoreDB::addStudent(Student s)&#10;    {&#10;        int id = s.GetId();&#10;        if (stu.contains(id))&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Add failed: Student ID {} already exists.&quot;, id));&#10;        }&#10;&#10;        auto [it, success] = stu.emplace(id, std::move(s));&#10;        return DynamicWrapper&lt;Student&gt;(it-&gt;second, _stu_schema);&#10;    }&#10;&#10;    DynamicWrapper&lt;Student&gt; SecScoreDB::addStudent(const DynamicWrapper&lt;Student&gt;&amp; s)&#10;    {&#10;        // 从传入的 Wrapper 中获取底层实体（复制一份）&#10;        Student copyEntity = s.GetEntity();&#10;        int id = copyEntity.GetId();&#10;&#10;        if (stu.contains(id))&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Import failed: Student ID {} already exists.&quot;, id));&#10;        }&#10;&#10;        auto [it, success] = stu.emplace(id, std::move(copyEntity));&#10;        return DynamicWrapper&lt;Student&gt;(it-&gt;second, _stu_schema);&#10;    }&#10;&#10;    DynamicWrapper&lt;Student&gt; SecScoreDB::getStudent(int id)&#10;    {&#10;        auto it = stu.find(id);&#10;        if (it == stu.end())&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Student ID {} not found.&quot;, id));&#10;        }&#10;        return DynamicWrapper&lt;Student&gt;(it-&gt;second, _stu_schema);&#10;    }&#10;&#10;    bool SecScoreDB::deleteStudent(int id)&#10;    {&#10;        return stu.erase(id) &gt; 0;&#10;    }&#10;&#10;    // ============================================================&#10;    // Group 相关实现&#10;    // ============================================================&#10;&#10;    DynamicWrapper&lt;Group&gt; SecScoreDB::createGroup(int id)&#10;    {&#10;        if (grp.contains(id))&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Create failed: Group ID {} already exists.&quot;, id));&#10;        }&#10;&#10;        Group g;&#10;        g.SetId(id);&#10;&#10;        auto [it, success] = grp.emplace(id, std::move(g));&#10;        return DynamicWrapper&lt;Group&gt;(it-&gt;second, _grp_schema);&#10;    }&#10;&#10;    DynamicWrapper&lt;Group&gt; SecScoreDB::addGroup(Group g)&#10;    {&#10;        int id = g.GetId();&#10;        if (grp.contains(id))&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Add failed: Group ID {} already exists.&quot;, id));&#10;        }&#10;&#10;        auto [it, success] = grp.emplace(id, std::move(g));&#10;        return DynamicWrapper&lt;Group&gt;(it-&gt;second, _grp_schema);&#10;    }&#10;&#10;    DynamicWrapper&lt;Group&gt; SecScoreDB::addGroup(const DynamicWrapper&lt;Group&gt;&amp; g)&#10;    {&#10;        Group copyEntity = g.GetEntity();&#10;        int id = copyEntity.GetId();&#10;&#10;        if (grp.contains(id))&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Import failed: Group ID {} already exists.&quot;, id));&#10;        }&#10;&#10;        auto [it, success] = grp.emplace(id, std::move(copyEntity));&#10;        return DynamicWrapper&lt;Group&gt;(it-&gt;second, _grp_schema);&#10;    }&#10;&#10;    DynamicWrapper&lt;Group&gt; SecScoreDB::getGroup(int id)&#10;    {&#10;        auto it = grp.find(id);&#10;        if (it == grp.end())&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Group ID {} not found.&quot;, id));&#10;        }&#10;        return DynamicWrapper&lt;Group&gt;(it-&gt;second, _grp_schema);&#10;    }&#10;&#10;    bool SecScoreDB::deleteGroup(int id)&#10;    {&#10;        return grp.erase(id) &gt; 0;&#10;    }&#10;&#10;    void SecScoreDB::addEvent(Event e)&#10;    {&#10;        int inputId = e.GetId();&#10;        if (inputId == INVALID_ID) // 分配新的 id&#10;        {&#10;            _max_event_id++;&#10;            e.SetId(_max_event_id);&#10;        }&#10;        else&#10;        {&#10;            if (evt.contains(inputId))&#10;            {&#10;                throw std::runtime_error(std::format(&quot;Add Event using ID {} failed: ID already exists.&quot;, inputId));&#10;            }&#10;            _max_event_id = (inputId &gt; _max_event_id ? inputId : _max_event_id);&#10;        }&#10;        // 实际插入事件存储&#10;        evt.emplace(e.GetId(), std::move(e));&#10;    }&#10;&#10;    void SecScoreDB::setEventErased(int id, bool isErased)&#10;    {&#10;        if (!this-&gt;evt.contains(id))&#10;            throw std::runtime_error(std::format(&quot;Event ID {} not found.&quot;, id));&#10;        auto it = evt.find(id);&#10;        it-&gt;second.SetErased(isErased);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;SecScoreDB.h&quot;&#10;#include &lt;algorithm&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;format&gt; // C++20&#10;&#10;namespace SSDB&#10;{&#10;    // ============================================================&#10;    // 构造与析构&#10;    // ============================================================&#10;&#10;    SecScoreDB::SecScoreDB(const std::filesystem::path&amp; path)&#10;        : stu_db(path / &quot;students.bin&quot;), // 使用二进制后缀&#10;          grp_db(path / &quot;groups.bin&quot;),&#10;          evt_db(path / &quot;events.bin&quot;)&#10;    {&#10;        // 一行代码完成加载！&#10;        stu = stu_db.LoadAll&lt;Student&gt;();&#10;        grp = grp_db.LoadAll&lt;Group&gt;();&#10;        evt = evt_db.LoadAll&lt;Event&gt;();&#10;&#10;        // 初始化 Event计数器&#10;        _max_event_id = 0;&#10;        for (const auto&amp; [id, _] : evt)&#10;        {&#10;            if (id &gt; _max_event_id)&#10;            {&#10;                _max_event_id = id;&#10;            }&#10;        }&#10;&#10;        _max_student_id = 0;&#10;        for (const auto&amp; [id, _] : stu)&#10;        {&#10;            if (id &gt; _max_student_id)&#10;            {&#10;                _max_student_id = id;&#10;            }&#10;        }&#10;&#10;        _max_group_id = 0;&#10;        for (const auto&amp; [id, _] : grp)&#10;        {&#10;            if (id &gt; _max_group_id)&#10;            {&#10;                _max_group_id = id;&#10;            }&#10;        }&#10;&#10;        // 打印日志&#10;        // std::cout &lt;&lt; &quot;Loaded &quot; &lt;&lt; stu.size() &lt;&lt; &quot; students.&quot; &lt;&lt; std::endl;&#10;    }&#10;&#10;    SecScoreDB::~SecScoreDB()&#10;    {&#10;        try&#10;        {&#10;            commit(); // 析构时自动保存&#10;        }&#10;        catch (const std::exception&amp; e)&#10;        {&#10;            // 析构函数绝对不能抛出异常，只能记录日志&#10;            std::cerr &lt;&lt; &quot;[SSDB Error] Failed to save DB on exit: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        }&#10;    }&#10;&#10;    void SecScoreDB::commit()&#10;    {&#10;        // 一行代码完成保存！&#10;        stu_db.SaveAll(stu);&#10;        grp_db.SaveAll(grp);&#10;        evt_db.SaveAll(evt);&#10;    }&#10;&#10;    // ============================================================&#10;    // Student 相关实现&#10;    // ============================================================&#10;&#10;    DynamicWrapper&lt;Student&gt; SecScoreDB::createStudent(int id)&#10;    {&#10;        if (stu.contains(id))&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Create failed: Student ID {} already exists.&quot;, id));&#10;        }&#10;&#10;        Student s;&#10;        s.SetId(id);&#10;&#10;        _max_student_id = std::max(_max_student_id, id);&#10;&#10;        // 移动语义插入，高效&#10;        auto [it, success] = stu.emplace(id, std::move(s));&#10;        _max_student_id = std::max(_max_student_id, id);&#10;        return DynamicWrapper&lt;Student&gt;(it-&gt;second, _stu_schema);&#10;    }&#10;&#10;    DynamicWrapper&lt;Student&gt; SecScoreDB::addStudent(Student s)&#10;    {&#10;        int id = s.GetId();&#10;        if (stu.contains(id))&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Add failed: Student ID {} already exists.&quot;, id));&#10;        }&#10;&#10;        auto [it, success] = stu.emplace(id, std::move(s));&#10;        _max_student_id = std::max(_max_student_id, id);&#10;        return DynamicWrapper&lt;Student&gt;(it-&gt;second, _stu_schema);&#10;    }&#10;&#10;    DynamicWrapper&lt;Student&gt; SecScoreDB::addStudent(const DynamicWrapper&lt;Student&gt;&amp; s)&#10;    {&#10;        // 从传入的 Wrapper 中获取底层实体（复制一份）&#10;        Student copyEntity = s.GetEntity();&#10;        int id = copyEntity.GetId();&#10;&#10;        if (stu.contains(id))&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Import failed: Student ID {} already exists.&quot;, id));&#10;        }&#10;&#10;        auto [it, success] = stu.emplace(id, std::move(copyEntity));&#10;        _max_student_id = std::max(_max_student_id, id);&#10;        return DynamicWrapper&lt;Student&gt;(it-&gt;second, _stu_schema);&#10;    }&#10;&#10;    DynamicWrapper&lt;Student&gt; SecScoreDB::getStudent(int id)&#10;    {&#10;        auto it = stu.find(id);&#10;        if (it == stu.end())&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Student ID {} not found.&quot;, id));&#10;        }&#10;        return DynamicWrapper&lt;Student&gt;(it-&gt;second, _stu_schema);&#10;    }&#10;&#10;    bool SecScoreDB::deleteStudent(int id)&#10;    {&#10;        return stu.erase(id) &gt; 0;&#10;    }&#10;&#10;    // ============================================================&#10;    // Group 相关实现&#10;    // ============================================================&#10;&#10;    DynamicWrapper&lt;Group&gt; SecScoreDB::createGroup(int id)&#10;    {&#10;        if (grp.contains(id))&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Create failed: Group ID {} already exists.&quot;, id));&#10;        }&#10;&#10;        Group g;&#10;        g.SetId(id);&#10;&#10;        _max_group_id = std::max(_max_group_id, id);&#10;&#10;        auto [it, success] = grp.emplace(id, std::move(g));&#10;        _max_group_id = std::max(_max_group_id, id);&#10;        return DynamicWrapper&lt;Group&gt;(it-&gt;second, _grp_schema);&#10;    }&#10;&#10;    DynamicWrapper&lt;Group&gt; SecScoreDB::addGroup(Group g)&#10;    {&#10;        int id = g.GetId();&#10;        if (grp.contains(id))&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Add failed: Group ID {} already exists.&quot;, id));&#10;        }&#10;&#10;        auto [it, success] = grp.emplace(id, std::move(g));&#10;        _max_group_id = std::max(_max_group_id, id);&#10;        return DynamicWrapper&lt;Group&gt;(it-&gt;second, _grp_schema);&#10;    }&#10;&#10;    DynamicWrapper&lt;Group&gt; SecScoreDB::addGroup(const DynamicWrapper&lt;Group&gt;&amp; g)&#10;    {&#10;        Group copyEntity = g.GetEntity();&#10;        int id = copyEntity.GetId();&#10;&#10;        if (grp.contains(id))&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Import failed: Group ID {} already exists.&quot;, id));&#10;        }&#10;&#10;        auto [it, success] = grp.emplace(id, std::move(copyEntity));&#10;        _max_group_id = std::max(_max_group_id, id);&#10;        return DynamicWrapper&lt;Group&gt;(it-&gt;second, _grp_schema);&#10;    }&#10;&#10;    DynamicWrapper&lt;Group&gt; SecScoreDB::getGroup(int id)&#10;    {&#10;        auto it = grp.find(id);&#10;        if (it == grp.end())&#10;        {&#10;            throw std::runtime_error(std::format(&quot;Group ID {} not found.&quot;, id));&#10;        }&#10;        return DynamicWrapper&lt;Group&gt;(it-&gt;second, _grp_schema);&#10;    }&#10;&#10;    bool SecScoreDB::deleteGroup(int id)&#10;    {&#10;        return grp.erase(id) &gt; 0;&#10;    }&#10;&#10;    int SecScoreDB::addEvent(Event e)&#10;    {&#10;        int inputId = e.GetId();&#10;        if (inputId == INVALID_ID) // 分配新的 id&#10;        {&#10;            _max_event_id++;&#10;            e.SetId(_max_event_id);&#10;        }&#10;        else&#10;        {&#10;            if (evt.contains(inputId))&#10;            {&#10;                throw std::runtime_error(std::format(&quot;Add Event using ID {} failed: ID already exists.&quot;, inputId));&#10;            }&#10;            _max_event_id = (inputId &gt; _max_event_id ? inputId : _max_event_id);&#10;        }&#10;        // 实际插入事件存储&#10;        evt.emplace(e.GetId(), std::move(e));&#10;        return _max_event_id;&#10;    }&#10;&#10;    void SecScoreDB::setEventErased(int id, bool isErased)&#10;    {&#10;        if (!this-&gt;evt.contains(id))&#10;            throw std::runtime_error(std::format(&quot;Event ID {} not found.&quot;, id));&#10;        auto it = evt.find(id);&#10;        it-&gt;second.SetErased(isErased);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/SecScoreDB.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/SecScoreDB.h" />
              <option name="originalContent" value="#pragma once&#10;#include &quot;FileHelper.h&quot;&#10;#include &lt;string&gt;&#10;#include &quot;Student.h&quot;&#10;#include &quot;Event.h&quot;&#10;#include &quot;Group.h&quot;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;filesystem&gt;&#10;#include &lt;deque&gt;&#10;&#10;#include &quot;DynamicFields.hpp&quot;&#10;#include &lt;functional&gt;&#10;&#10;namespace SSDB&#10;{&#10;    class SecScoreDB&#10;    {&#10;    private:&#10;        DataBaseFile stu_db;&#10;        DataBaseFile grp_db;&#10;        DataBaseFile evt_db;&#10;        std::unordered_map&lt;int, Student&gt; stu;&#10;        std::unordered_map&lt;int, Event&gt; evt;&#10;        std::unordered_map&lt;int, Group&gt; grp;&#10;&#10;        //schema&#10;        SchemaDef _stu_schema;&#10;        SchemaDef _grp_schema;&#10;        //other things&#10;&#10;        int _max_event_id = 0;&#10;&#10;        void assertStudentSchema() const&#10;        {&#10;            if (_stu_schema.empty())&#10;                throw std::runtime_error(&quot;Operation failed: Student Schema is not initialized.&quot;);&#10;        }&#10;&#10;        void assertGroupSchema() const&#10;        {&#10;            if (_grp_schema.empty())&#10;                throw std::runtime_error(&quot;Operation failed: Group Schema is not initialized.&quot;);&#10;        }&#10;&#10;    public:&#10;        explicit SecScoreDB(const std::filesystem::path&amp; path);&#10;        ~SecScoreDB();&#10;&#10;        // init schema for grp &amp; stu&#10;&#10;        void initStudentSchema(const SchemaDef&amp; schema)&#10;        {&#10;            this-&gt;_stu_schema = schema;&#10;        }&#10;&#10;        void initGroupSchema(const SchemaDef&amp; schema)&#10;        {&#10;            this-&gt;_grp_schema = schema;&#10;        }&#10;&#10;        // 增&#10;        DynamicWrapper&lt;Student&gt; createStudent(int id);&#10;        DynamicWrapper&lt;Group&gt; createGroup(int id);&#10;&#10;        DynamicWrapper&lt;Student&gt; addStudent(Student s);&#10;        DynamicWrapper&lt;Group&gt; addGroup(Group g);&#10;        DynamicWrapper&lt;Student&gt; addStudent(const DynamicWrapper&lt;Student&gt;&amp; s);&#10;        DynamicWrapper&lt;Group&gt; addGroup(const DynamicWrapper&lt;Group&gt;&amp; g);&#10;&#10;        //查&#10;        DynamicWrapper&lt;Student&gt; getStudent(int id);&#10;        DynamicWrapper&lt;Group&gt; getGroup(int id);&#10;&#10;        template &lt;typename Predicate&gt;&#10;        std::vector&lt;DynamicWrapper&lt;Student&gt;&gt; getStudent(Predicate&amp;&amp; pred)&#10;        {&#10;            std::vector&lt;DynamicWrapper&lt;Student&gt;&gt; results;&#10;&#10;            // 遍历内存中的所有学生&#10;            for (auto&amp; [id, entity] : stu)&#10;            {&#10;                // 1. 创建一个临时的 Wrapper 用于检查条件&#10;                DynamicWrapper&lt;Student&gt; wrapper(entity, _stu_schema);&#10;&#10;                try&#10;                {&#10;                    // 2. 执行用户传入的 Lambda&#10;                    // 如果 Lambda 返回 true，则匹配成功&#10;                    if (pred(wrapper))&#10;                    {&#10;                        // 3. 将匹配的对象加入结果集&#10;                        // 注意：我们重新构造一个 Wrapper 放入 vector，因为 Wrapper 是引用视图，拷贝开销极小&#10;                        results.push_back(DynamicWrapper&lt;Student&gt;(entity, _stu_schema));&#10;                    }&#10;                }&#10;                catch (...)&#10;                {&#10;                    // 4. 容错处理&#10;                    // 如果 Lambda 中访问了不存在的字段或类型错误导致抛出异常，&#10;                    // 我们认为这条记录不匹配，直接跳过 (continue)&#10;                    continue;&#10;                }&#10;            }&#10;            return results;&#10;        }&#10;&#10;        template &lt;typename Predicate&gt;&#10;        std::vector&lt;DynamicWrapper&lt;Group&gt;&gt; getGroup(Predicate&amp;&amp; pred)&#10;        {&#10;            std::vector&lt;DynamicWrapper&lt;Group&gt;&gt; results;&#10;&#10;            for (auto&amp; [id, entity] : grp)&#10;            {&#10;                DynamicWrapper&lt;Group&gt; wrapper(entity, _grp_schema);&#10;&#10;                try&#10;                {&#10;                    if (pred(wrapper))&#10;                    {&#10;                        results.push_back(DynamicWrapper&lt;Group&gt;(entity, _grp_schema));&#10;                    }&#10;                }&#10;                catch (...)&#10;                {&#10;                    continue;&#10;                }&#10;            }&#10;            return results;&#10;        }&#10;&#10;        //删&#10;        bool deleteStudent(int id);&#10;        bool deleteGroup(int id);&#10;&#10;        template &lt;typename Predicate&gt;&#10;        size_t deleteStudent(Predicate&amp;&amp; pred)&#10;        {&#10;            // C++20 std::erase_if&#10;            // 遍历 map，如果 pred 返回 true 则删除该元素&#10;            return std::erase_if(stu, [&amp;](auto&amp; pair)&#10;            {&#10;                // pair.second 是 Student 对象&#10;                // 我们需要 const_cast，因为 DynamicWrapper 通常接受非 const 引用&#10;                // 但我们在 predicate 里应该只读，不改。&#10;                Student&amp; entity = const_cast&lt;Student&amp;&gt;(pair.second);&#10;&#10;                DynamicWrapper&lt;Student&gt; wrapper(entity, _stu_schema);&#10;                try&#10;                {&#10;                    return pred(wrapper);&#10;                }&#10;                catch (...)&#10;                {&#10;                    return false; // 出错不删&#10;                }&#10;            });&#10;        }&#10;&#10;        template &lt;typename Predicate&gt;&#10;        size_t deleteGroup(Predicate&amp;&amp; pred)&#10;        {&#10;            return std::erase_if(grp, [&amp;](auto&amp; pair)&#10;            {&#10;                Group&amp; entity = pair.second;&#10;                DynamicWrapper&lt;Group&gt; wrapper(entity, _grp_schema);&#10;                try&#10;                {&#10;                    return pred(wrapper);&#10;                }&#10;                catch (...)&#10;                {&#10;                    return false;&#10;                }&#10;            });&#10;        }&#10;&#10;        //改：外面直接操作&#10;&#10;        // 简单事件操作&#10;&#10;        void addEvent(Event e);&#10;        void setEventErased(int id, bool isErased = true);&#10;&#10;        template &lt;typename Predicate&gt;&#10;        std::vector&lt;std::reference_wrapper&lt;const Event&gt;&gt; getEvents(Predicate&amp;&amp; pred) const&#10;        {&#10;            std::vector&lt;std::reference_wrapper&lt;const Event&gt;&gt; results;&#10;            results.reserve(16); // 预留一点空间，稍微优化下&#10;&#10;            for (const auto&amp; [id, e] : evt)&#10;            {&#10;                // 直接把 const Event&amp; 传给 lambda&#10;                if (pred(e))&#10;                {&#10;                    // 存入 reference_wrapper&#10;                    results.emplace_back(e);&#10;                }&#10;            }&#10;            return results;&#10;        }&#10;&#10;        // 数据库事务相关&#10;&#10;        void commit();&#10;    };&#10;}&#10;" />
              <option name="updatedContent" value="#pragma once&#10;#include &quot;FileHelper.h&quot;&#10;#include &lt;string&gt;&#10;#include &quot;Student.h&quot;&#10;#include &quot;Event.h&quot;&#10;#include &quot;Group.h&quot;&#10;#include &lt;unordered_map&gt;&#10;#include &lt;filesystem&gt;&#10;#include &lt;deque&gt;&#10;&#10;#include &quot;DynamicFields.hpp&quot;&#10;#include &lt;functional&gt;&#10;&#10;namespace SSDB&#10;{&#10;    class SecScoreDB&#10;    {&#10;    private:&#10;        DataBaseFile stu_db;&#10;        DataBaseFile grp_db;&#10;        DataBaseFile evt_db;&#10;        std::unordered_map&lt;int, Student&gt; stu;&#10;        std::unordered_map&lt;int, Event&gt; evt;&#10;        std::unordered_map&lt;int, Group&gt; grp;&#10;&#10;        //schema&#10;        SchemaDef _stu_schema;&#10;        SchemaDef _grp_schema;&#10;        //other things&#10;&#10;        int _max_event_id = 0;&#10;        int _max_student_id = 0;&#10;        int _max_group_id = 0;&#10;&#10;        void assertStudentSchema() const&#10;        {&#10;            if (_stu_schema.empty())&#10;                throw std::runtime_error(&quot;Operation failed: Student Schema is not initialized.&quot;);&#10;        }&#10;&#10;        void assertGroupSchema() const&#10;        {&#10;            if (_grp_schema.empty())&#10;                throw std::runtime_error(&quot;Operation failed: Group Schema is not initialized.&quot;);&#10;        }&#10;&#10;    public:&#10;        explicit SecScoreDB(const std::filesystem::path&amp; path);&#10;        ~SecScoreDB();&#10;&#10;        // init schema for grp &amp; stu&#10;&#10;        void initStudentSchema(const SchemaDef&amp; schema)&#10;        {&#10;            this-&gt;_stu_schema = schema;&#10;        }&#10;&#10;        void initGroupSchema(const SchemaDef&amp; schema)&#10;        {&#10;            this-&gt;_grp_schema = schema;&#10;        }&#10;&#10;        int allocateStudentId()&#10;        {&#10;            return ++_max_student_id;&#10;        }&#10;&#10;        int allocateGroupId()&#10;        {&#10;            return ++_max_group_id;&#10;        }&#10;&#10;        bool hasStudent(int id) const { return stu.contains(id); }&#10;        bool hasGroup(int id) const { return grp.contains(id); }&#10;&#10;        const std::unordered_map&lt;int, Student&gt;&amp; students() const { return stu; }&#10;        const std::unordered_map&lt;int, Group&gt;&amp; groups() const { return grp; }&#10;        const SchemaDef&amp; studentSchema() const { return _stu_schema; }&#10;        const SchemaDef&amp; groupSchema() const { return _grp_schema; }&#10;&#10;        // 增&#10;        DynamicWrapper&lt;Student&gt; createStudent(int id);&#10;        DynamicWrapper&lt;Group&gt; createGroup(int id);&#10;&#10;        DynamicWrapper&lt;Student&gt; addStudent(Student s);&#10;        DynamicWrapper&lt;Group&gt; addGroup(Group g);&#10;        DynamicWrapper&lt;Student&gt; addStudent(const DynamicWrapper&lt;Student&gt;&amp; s);&#10;        DynamicWrapper&lt;Group&gt; addGroup(const DynamicWrapper&lt;Group&gt;&amp; g);&#10;&#10;        //查&#10;        DynamicWrapper&lt;Student&gt; getStudent(int id);&#10;        DynamicWrapper&lt;Group&gt; getGroup(int id);&#10;&#10;        template &lt;typename Predicate&gt;&#10;        std::vector&lt;DynamicWrapper&lt;Student&gt;&gt; getStudent(Predicate&amp;&amp; pred)&#10;        {&#10;            std::vector&lt;DynamicWrapper&lt;Student&gt;&gt; results;&#10;&#10;            // 遍历内存中的所有学生&#10;            for (auto&amp; [id, entity] : stu)&#10;            {&#10;                // 1. 创建一个临时的 Wrapper 用于检查条件&#10;                DynamicWrapper&lt;Student&gt; wrapper(entity, _stu_schema);&#10;&#10;                try&#10;                {&#10;                    // 2. 执行用户传入的 Lambda&#10;                    // 如果 Lambda 返回 true，则匹配成功&#10;                    if (pred(wrapper))&#10;                    {&#10;                        // 3. 将匹配的对象加入结果集&#10;                        // 注意：我们重新构造一个 Wrapper 放入 vector，因为 Wrapper 是引用视图，拷贝开销极小&#10;                        results.push_back(DynamicWrapper&lt;Student&gt;(entity, _stu_schema));&#10;                    }&#10;                }&#10;                catch (...)&#10;                {&#10;                    // 4. 容错处理&#10;                    // 如果 Lambda 中访问了不存在的字段或类型错误导致抛出异常，&#10;                    // 我们认为这条记录不匹配，直接跳过 (continue)&#10;                    continue;&#10;                }&#10;            }&#10;            return results;&#10;        }&#10;&#10;        template &lt;typename Predicate&gt;&#10;        std::vector&lt;DynamicWrapper&lt;Group&gt;&gt; getGroup(Predicate&amp;&amp; pred)&#10;        {&#10;            std::vector&lt;DynamicWrapper&lt;Group&gt;&gt; results;&#10;&#10;            for (auto&amp; [id, entity] : grp)&#10;            {&#10;                DynamicWrapper&lt;Group&gt; wrapper(entity, _grp_schema);&#10;&#10;                try&#10;                {&#10;                    if (pred(wrapper))&#10;                    {&#10;                        results.push_back(DynamicWrapper&lt;Group&gt;(entity, _grp_schema));&#10;                    }&#10;                }&#10;                catch (...)&#10;                {&#10;                    continue;&#10;                }&#10;            }&#10;            return results;&#10;        }&#10;&#10;        //删&#10;        bool deleteStudent(int id);&#10;        bool deleteGroup(int id);&#10;&#10;        template &lt;typename Predicate&gt;&#10;        size_t deleteStudent(Predicate&amp;&amp; pred)&#10;        {&#10;            // C++20 std::erase_if&#10;            // 遍历 map，如果 pred 返回 true 则删除该元素&#10;            return std::erase_if(stu, [&amp;](auto&amp; pair)&#10;            {&#10;                // pair.second 是 Student 对象&#10;                // 我们需要 const_cast，因为 DynamicWrapper 通常接受非 const 引用&#10;                // 但我们在 predicate 里应该只读，不改。&#10;                Student&amp; entity = const_cast&lt;Student&amp;&gt;(pair.second);&#10;&#10;                DynamicWrapper&lt;Student&gt; wrapper(entity, _stu_schema);&#10;                try&#10;                {&#10;                    return pred(wrapper);&#10;                }&#10;                catch (...)&#10;                {&#10;                    return false; // 出错不删&#10;                }&#10;            });&#10;        }&#10;&#10;        template &lt;typename Predicate&gt;&#10;        size_t deleteGroup(Predicate&amp;&amp; pred)&#10;        {&#10;            return std::erase_if(grp, [&amp;](auto&amp; pair)&#10;            {&#10;                Group&amp; entity = pair.second;&#10;                DynamicWrapper&lt;Group&gt; wrapper(entity, _grp_schema);&#10;                try&#10;                {&#10;                    return pred(wrapper);&#10;                }&#10;                catch (...)&#10;                {&#10;                    return false;&#10;                }&#10;            });&#10;        }&#10;&#10;        //改：外面直接操作&#10;&#10;        // 简单事件操作&#10;&#10;        int addEvent(Event e);&#10;        void setEventErased(int id, bool isErased = true);&#10;&#10;        template &lt;typename Predicate&gt;&#10;        std::vector&lt;std::reference_wrapper&lt;const Event&gt;&gt; getEvents(Predicate&amp;&amp; pred) const&#10;        {&#10;            std::vector&lt;std::reference_wrapper&lt;const Event&gt;&gt; results;&#10;            results.reserve(16); // 预留一点空间，稍微优化下&#10;&#10;            for (const auto&amp; [id, e] : evt)&#10;            {&#10;                // 直接把 const Event&amp; 传给 lambda&#10;                if (pred(e))&#10;                {&#10;                    // 存入 reference_wrapper&#10;                    results.emplace_back(e);&#10;                }&#10;            }&#10;            return results;&#10;        }&#10;&#10;        // 数据库事务相关&#10;&#10;        void commit();&#10;    };&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wrappers/websockets/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wrappers/websockets/main.cpp" />
              <option name="originalContent" value="#include &lt;iostream&gt;&#10;#include &lt;nlohmann/json.hpp&gt;&#10;#include &lt;ixwebsocket/IXWebSocketServer.h&gt;&#10;&#10;using namespace std;&#10;&#10;int main()&#10;{&#10;&#10;}" />
              <option name="updatedContent" value="#include &lt;chrono&gt;&#10;#include &lt;cstdint&gt;&#10;#include &lt;cmath&gt;&#10;#include &lt;filesystem&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;limits&gt;&#10;#include &lt;mutex&gt;&#10;#include &lt;optional&gt;&#10;#include &lt;string&gt;&#10;#include &lt;string_view&gt;&#10;#include &lt;algorithm&gt;&#10;&#10;#include &lt;nlohmann/json.hpp&gt;&#10;#include &lt;ixwebsocket/IXWebSocketServer.h&gt;&#10;#include &lt;ixwebsocket/IXNetSystem.h&gt;&#10;&#10;#include &quot;SecScoreDB.h&quot;&#10;&#10;using nlohmann::json;&#10;using SSDB::FieldType;&#10;using SSDB::SchemaDef;&#10;&#10;namespace&#10;{&#10;    struct ApiError : std::runtime_error&#10;    {&#10;        int code;&#10;        ApiError(int c, std::string msg) : std::runtime_error(std::move(msg)), code(c) {}&#10;    };&#10;&#10;    std::string toLowerCopy(std::string_view view)&#10;    {&#10;        std::string out(view.begin(), view.end());&#10;        std::transform(out.begin(), out.end(), out.begin(), [](unsigned char c) { return static_cast&lt;char&gt;(std::tolower(c)); });&#10;        return out;&#10;    }&#10;&#10;    std::string toUpperCopy(std::string_view view)&#10;    {&#10;        std::string out(view.begin(), view.end());&#10;        std::transform(out.begin(), out.end(), out.begin(), [](unsigned char c) { return static_cast&lt;char&gt;(std::toupper(c)); });&#10;        return out;&#10;    }&#10;&#10;    const char* fieldTypeName(FieldType type)&#10;    {&#10;        switch (type)&#10;        {&#10;        case FieldType::Int: return &quot;int&quot;;&#10;        case FieldType::Double: return &quot;double&quot;;&#10;        case FieldType::String: return &quot;string&quot;;&#10;        default: return &quot;unknown&quot;;&#10;        }&#10;    }&#10;&#10;    FieldType parseFieldType(const std::string&amp; value)&#10;    {&#10;        auto lower = toLowerCopy(value);&#10;        if (lower == &quot;string&quot;) return FieldType::String;&#10;        if (lower == &quot;int&quot;) return FieldType::Int;&#10;        if (lower == &quot;double&quot;) return FieldType::Double;&#10;        throw ApiError(400, &quot;Unsupported field type: &quot; + value);&#10;    }&#10;&#10;    void ensureSchemaReady(const SchemaDef&amp; schema, std::string_view target)&#10;    {&#10;        if (schema.empty())&#10;        {&#10;            throw ApiError(422, std::string(target) + &quot; schema is not defined.&quot;);&#10;        }&#10;    }&#10;&#10;    SchemaDef parseSchema(const json&amp; schemaJson)&#10;    {&#10;        if (!schemaJson.is_object() || schemaJson.empty())&#10;        {&#10;            throw ApiError(400, &quot;schema must be a non-empty object.&quot;);&#10;        }&#10;&#10;        SchemaDef schema;&#10;        for (const auto&amp; [field, typeNode] : schemaJson.items())&#10;        {&#10;            if (!typeNode.is_string())&#10;            {&#10;                throw ApiError(400, &quot;Field type for '&quot; + field + &quot;' must be string.&quot;);&#10;            }&#10;            schema[field] = parseFieldType(typeNode.get&lt;std::string&gt;());&#10;        }&#10;        return schema;&#10;    }&#10;&#10;    std::optional&lt;json&gt; decodeStoredValue(const std::string&amp; raw, FieldType type)&#10;    {&#10;        try&#10;        {&#10;            switch (type)&#10;            {&#10;            case FieldType::String:&#10;                return raw;&#10;            case FieldType::Int:&#10;                return static_cast&lt;long long&gt;(std::stoll(raw));&#10;            case FieldType::Double:&#10;                return std::stod(raw);&#10;            default:&#10;                return std::nullopt;&#10;            }&#10;        }&#10;        catch (...)&#10;        {&#10;            return std::nullopt;&#10;        }&#10;    }&#10;&#10;    template &lt;typename Entity&gt;&#10;    json materializeEntityData(const Entity&amp; entity, const SchemaDef&amp; schema)&#10;    {&#10;        json data = json::object();&#10;        const auto&amp; meta = entity.GetMetadata();&#10;        for (const auto&amp; [field, type] : schema)&#10;        {&#10;            auto it = meta.find(field);&#10;            if (it == meta.end())&#10;            {&#10;                continue;&#10;            }&#10;            if (auto decoded = decodeStoredValue(it-&gt;second, type))&#10;            {&#10;                data[field] = *decoded;&#10;            }&#10;        }&#10;        return data;&#10;    }&#10;&#10;    double requireNumber(const json&amp; value, std::string_view context)&#10;    {&#10;        if (!value.is_number())&#10;        {&#10;            throw ApiError(422, std::string(context) + &quot; must be numeric.&quot;);&#10;        }&#10;        return value.get&lt;double&gt;();&#10;    }&#10;&#10;    bool compareNumbers(double lhs, double rhs, const std::string&amp; op)&#10;    {&#10;        if (op == &quot;==&quot;) return lhs == rhs;&#10;        if (op == &quot;!=&quot;) return lhs != rhs;&#10;        if (op == &quot;&gt;&quot;) return lhs &gt; rhs;&#10;        if (op == &quot;&gt;=&quot;) return lhs &gt;= rhs;&#10;        if (op == &quot;&lt;&quot;) return lhs &lt; rhs;&#10;        if (op == &quot;&lt;=&quot;) return lhs &lt;= rhs;&#10;        throw ApiError(422, &quot;Unsupported numeric operator: &quot; + op);&#10;    }&#10;&#10;    bool compareStrings(const std::string&amp; lhs, const std::string&amp; rhs, const std::string&amp; opLower)&#10;    {&#10;        if (opLower == &quot;==&quot;) return lhs == rhs;&#10;        if (opLower == &quot;!=&quot;) return lhs != rhs;&#10;        if (opLower == &quot;contains&quot;) return lhs.find(rhs) != std::string::npos;&#10;        if (opLower == &quot;starts_with&quot;) return lhs.rfind(rhs, 0) == 0;&#10;        if (opLower == &quot;ends_with&quot;)&#10;        {&#10;            if (rhs.size() &gt; lhs.size()) return false;&#10;            return std::equal(rhs.rbegin(), rhs.rend(), lhs.rbegin());&#10;        }&#10;        throw ApiError(422, &quot;Unsupported string operator: &quot; + opLower);&#10;    }&#10;&#10;    bool evaluateLogicNode(const json&amp; entityData, const json&amp; node, const SchemaDef&amp; schema)&#10;    {&#10;        if (!node.is_object())&#10;        {&#10;            throw ApiError(400, &quot;logic node must be an object.&quot;);&#10;        }&#10;&#10;        if (node.contains(&quot;field&quot;))&#10;        {&#10;            auto field = node.at(&quot;field&quot;).get&lt;std::string&gt;();&#10;            auto opRaw = node.at(&quot;op&quot;).get&lt;std::string&gt;();&#10;            if (!node.contains(&quot;val&quot;))&#10;            {&#10;                throw ApiError(400, &quot;Leaf rule is missing 'val'.&quot;);&#10;            }&#10;            auto schemaIt = schema.find(field);&#10;            if (schemaIt == schema.end())&#10;            {&#10;                throw ApiError(422, &quot;Field '&quot; + field + &quot;' is not defined in schema.&quot;);&#10;            }&#10;            if (!entityData.contains(field))&#10;            {&#10;                return false;&#10;            }&#10;            const auto&amp; lhs = entityData.at(field);&#10;            const auto&amp; rhs = node.at(&quot;val&quot;);&#10;            auto type = schemaIt-&gt;second;&#10;            if (type == FieldType::String)&#10;            {&#10;                if (!lhs.is_string() || !rhs.is_string())&#10;                {&#10;                    throw ApiError(422, &quot;String comparison requires string operands.&quot;);&#10;                }&#10;                return compareStrings(lhs.get_ref&lt;const std::string&amp;&gt;(), rhs.get_ref&lt;const std::string&amp;&gt;(), toLowerCopy(opRaw));&#10;            }&#10;            if (type == FieldType::Int || type == FieldType::Double)&#10;            {&#10;                double lhsVal = requireNumber(lhs, field);&#10;                double rhsVal = requireNumber(rhs, &quot;val&quot;);&#10;                return compareNumbers(lhsVal, rhsVal, opRaw);&#10;            }&#10;            throw ApiError(422, &quot;Unsupported field type in logic rule.&quot;);&#10;        }&#10;&#10;        auto op = toUpperCopy(node.at(&quot;op&quot;).get&lt;std::string&gt;());&#10;        const auto&amp; rules = node.at(&quot;rules&quot;);&#10;        if (!rules.is_array() || rules.empty())&#10;        {&#10;            throw ApiError(400, &quot;logic.rules must be a non-empty array.&quot;);&#10;        }&#10;&#10;        if (op == &quot;AND&quot;)&#10;        {&#10;            for (const auto&amp; child : rules)&#10;            {&#10;                if (!evaluateLogicNode(entityData, child, schema))&#10;                {&#10;                    return false;&#10;                }&#10;            }&#10;            return true;&#10;        }&#10;        if (op == &quot;OR&quot;)&#10;        {&#10;            for (const auto&amp; child : rules)&#10;            {&#10;                if (evaluateLogicNode(entityData, child, schema))&#10;                {&#10;                    return true;&#10;                }&#10;            }&#10;            return false;&#10;        }&#10;        throw ApiError(400, &quot;Unsupported logic operator: &quot; + op);&#10;    }&#10;&#10;    template &lt;typename Wrapper&gt;&#10;    void assignDynamicFields(Wrapper&amp; wrapper, const json&amp; data, const SchemaDef&amp; schema)&#10;    {&#10;        if (!data.is_object())&#10;        {&#10;            throw ApiError(400, &quot;data must be an object.&quot;);&#10;        }&#10;        for (const auto&amp; [field, value] : data.items())&#10;        {&#10;            auto it = schema.find(field);&#10;            if (it == schema.end())&#10;            {&#10;                throw ApiError(422, &quot;Field '&quot; + field + &quot;' is not defined in schema.&quot;);&#10;            }&#10;            switch (it-&gt;second)&#10;            {&#10;            case FieldType::String:&#10;                if (!value.is_string())&#10;                {&#10;                    throw ApiError(422, &quot;Field '&quot; + field + &quot;' requires string value.&quot;);&#10;                }&#10;                wrapper[field] = value.get_ref&lt;const std::string&amp;&gt;();&#10;                break;&#10;            case FieldType::Int:&#10;                if (!value.is_number_integer())&#10;                {&#10;                    throw ApiError(422, &quot;Field '&quot; + field + &quot;' requires integer value.&quot;);&#10;                }&#10;                wrapper[field] = value.get&lt;long long&gt;();&#10;                break;&#10;            case FieldType::Double:&#10;                if (!value.is_number())&#10;                {&#10;                    throw ApiError(422, &quot;Field '&quot; + field + &quot;' requires numeric value.&quot;);&#10;                }&#10;                wrapper[field] = value.get&lt;double&gt;();&#10;                break;&#10;            default:&#10;                throw ApiError(422, &quot;Unsupported field type for '&quot; + field + &quot;'.&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    template &lt;typename WrapperFactory, typename CleanupFn, typename AllocFn&gt;&#10;    json handleCreate(const json&amp; payload, const SchemaDef&amp; schema, WrapperFactory&amp;&amp; factory, CleanupFn&amp;&amp; cleanup, AllocFn&amp;&amp; allocator)&#10;    {&#10;        ensureSchemaReady(schema, &quot;entity&quot;);&#10;        if (!payload.contains(&quot;items&quot;) || !payload.at(&quot;items&quot;).is_array())&#10;        {&#10;            throw ApiError(400, &quot;payload.items must be an array.&quot;);&#10;        }&#10;&#10;        const auto&amp; items = payload.at(&quot;items&quot;);&#10;        json results = json::array();&#10;        size_t successCount = 0;&#10;        for (const auto&amp; item : items)&#10;        {&#10;            int index = item.value(&quot;index&quot;, 0);&#10;            try&#10;            {&#10;                if (!item.contains(&quot;data&quot;))&#10;                {&#10;                    throw ApiError(400, &quot;Each item must include data.&quot;);&#10;                }&#10;                int id;&#10;                if (!item.contains(&quot;id&quot;) || item.at(&quot;id&quot;).is_null())&#10;                {&#10;                    id = allocator();&#10;                }&#10;                else if (item.at(&quot;id&quot;).is_number_integer())&#10;                {&#10;                    id = item.at(&quot;id&quot;).get&lt;int&gt;();&#10;                }&#10;                else&#10;                {&#10;                    throw ApiError(422, &quot;id must be null or integer.&quot;);&#10;                }&#10;&#10;                auto wrapper = factory(id);&#10;                bool assigned = false;&#10;                try&#10;                {&#10;                    assignDynamicFields(wrapper, item.at(&quot;data&quot;), schema);&#10;                    assigned = true;&#10;                }&#10;                catch (...)&#10;                {&#10;                    cleanup(id);&#10;                    throw;&#10;                }&#10;&#10;                (void)assigned;&#10;                results.push_back({{&quot;index&quot;, index}, {&quot;success&quot;, true}, {&quot;id&quot;, id}});&#10;                successCount++;&#10;            }&#10;            catch (const ApiError&amp; err)&#10;            {&#10;                results.push_back({{&quot;index&quot;, index}, {&quot;success&quot;, false}, {&quot;message&quot;, err.what()}});&#10;            }&#10;            catch (const std::exception&amp; err)&#10;            {&#10;                results.push_back({{&quot;index&quot;, index}, {&quot;success&quot;, false}, {&quot;message&quot;, err.what()}});&#10;            }&#10;        }&#10;        return json{{&quot;count&quot;, successCount}, {&quot;results&quot;, results}};&#10;    }&#10;&#10;    template &lt;typename MapType&gt;&#10;    json handleQuery(const json&amp; payload, const MapType&amp; entities, const SchemaDef&amp; schema)&#10;    {&#10;        ensureSchemaReady(schema, &quot;entity&quot;);&#10;        size_t limit = std::numeric_limits&lt;size_t&gt;::max();&#10;        if (payload.contains(&quot;limit&quot;))&#10;        {&#10;            if (!payload.at(&quot;limit&quot;).is_number_unsigned())&#10;            {&#10;                throw ApiError(400, &quot;limit must be a non-negative integer.&quot;);&#10;            }&#10;            limit = payload.at(&quot;limit&quot;).get&lt;size_t&gt;();&#10;            if (limit == 0)&#10;            {&#10;                limit = std::numeric_limits&lt;size_t&gt;::max();&#10;            }&#10;        }&#10;        const json* logicNode = nullptr;&#10;        if (payload.contains(&quot;logic&quot;))&#10;        {&#10;            logicNode = &amp;payload.at(&quot;logic&quot;);&#10;        }&#10;&#10;        json items = json::array();&#10;        for (const auto&amp; [id, entity] : entities)&#10;        {&#10;            auto data = materializeEntityData(entity, schema);&#10;            bool matched = true;&#10;            if (logicNode &amp;&amp; !logicNode-&gt;is_null())&#10;            {&#10;                matched = evaluateLogicNode(data, *logicNode, schema);&#10;            }&#10;            if (matched)&#10;            {&#10;                items.push_back({{&quot;id&quot;, id}, {&quot;data&quot;, data}});&#10;                if (items.size() &gt;= limit)&#10;                {&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        return json{{&quot;items&quot;, items}};&#10;    }&#10;&#10;    template &lt;typename WrapperFetcher&gt;&#10;    json handleUpdate(const json&amp; payload, const SchemaDef&amp; schema, WrapperFetcher&amp;&amp; fetcher)&#10;    {&#10;        ensureSchemaReady(schema, &quot;entity&quot;);&#10;        if (!payload.contains(&quot;id&quot;) || !payload.at(&quot;id&quot;).is_number_integer())&#10;        {&#10;            throw ApiError(400, &quot;payload.id must be integer.&quot;);&#10;        }&#10;        if (!payload.contains(&quot;set&quot;))&#10;        {&#10;            throw ApiError(400, &quot;payload.set is required.&quot;);&#10;        }&#10;        int id = payload.at(&quot;id&quot;).get&lt;int&gt;();&#10;        auto wrapper = fetcher(id);&#10;        assignDynamicFields(wrapper, payload.at(&quot;set&quot;), schema);&#10;        return json{{&quot;id&quot;, id}, {&quot;updated&quot;, true}};&#10;    }&#10;&#10;    template &lt;typename DeleteFn&gt;&#10;    json handleDelete(const json&amp; payload, std::string_view targetName, DeleteFn&amp;&amp; deleter)&#10;    {&#10;        if (!payload.contains(&quot;id&quot;) || !payload.at(&quot;id&quot;).is_number_integer())&#10;        {&#10;            throw ApiError(400, &quot;payload.id must be integer.&quot;);&#10;        }&#10;        int id = payload.at(&quot;id&quot;).get&lt;int&gt;();&#10;        if (!deleter(id))&#10;        {&#10;            throw ApiError(404, std::string(targetName) + &quot; id not found.&quot;);&#10;        }&#10;        return json{{&quot;id&quot;, id}, {&quot;deleted&quot;, true}};&#10;    }&#10;&#10;    SSDB::EventType parseEventType(int type)&#10;    {&#10;        if (type == 1) return SSDB::EventType::STUDENT;&#10;        if (type == 2) return SSDB::EventType::GROUP;&#10;        throw ApiError(422, &quot;event.type must be 1 (student) or 2 (group).&quot;);&#10;    }&#10;&#10;    json makeOkResponse(const std::string&amp; seq, const json&amp; data = json::object())&#10;    {&#10;        json response{{&quot;seq&quot;, seq}, {&quot;status&quot;, &quot;ok&quot;}, {&quot;code&quot;, 200}};&#10;        if (!data.is_null())&#10;        {&#10;            response[&quot;data&quot;] = data;&#10;        }&#10;        return response;&#10;    }&#10;&#10;    json makeErrorResponse(const std::string&amp; seq, int code, const std::string&amp; message)&#10;    {&#10;        return json{{&quot;seq&quot;, seq}, {&quot;status&quot;, &quot;error&quot;}, {&quot;code&quot;, code}, {&quot;message&quot;, message}};&#10;    }&#10;&#10;    json handleSystem(const std::string&amp; actionRaw, const json&amp; payload, SSDB::SecScoreDB&amp; db, std::mutex&amp; mutex)&#10;    {&#10;        auto action = toLowerCopy(actionRaw);&#10;        if (action != &quot;define&quot;)&#10;        {&#10;            throw ApiError(400, &quot;Unsupported system action: &quot; + actionRaw);&#10;        }&#10;        if (!payload.contains(&quot;target&quot;) || !payload.at(&quot;target&quot;).is_string())&#10;        {&#10;            throw ApiError(400, &quot;payload.target must be string.&quot;);&#10;        }&#10;        if (!payload.contains(&quot;schema&quot;))&#10;        {&#10;            throw ApiError(400, &quot;payload.schema is required.&quot;);&#10;        }&#10;&#10;        auto target = toLowerCopy(payload.at(&quot;target&quot;).get&lt;std::string&gt;());&#10;        auto schema = parseSchema(payload.at(&quot;schema&quot;));&#10;        std::scoped_lock lock(mutex);&#10;        if (target == &quot;student&quot;)&#10;        {&#10;            db.initStudentSchema(schema);&#10;        }&#10;        else if (target == &quot;group&quot;)&#10;        {&#10;            db.initGroupSchema(schema);&#10;        }&#10;        else&#10;        {&#10;            throw ApiError(400, &quot;target must be 'student' or 'group'.&quot;);&#10;        }&#10;        return json{{&quot;target&quot;, target}, {&quot;fields&quot;, schema.size()}};&#10;    }&#10;&#10;    json handleStudent(const std::string&amp; actionRaw, const json&amp; payload, SSDB::SecScoreDB&amp; db, std::mutex&amp; mutex)&#10;    {&#10;        std::scoped_lock lock(mutex);&#10;        const auto&amp; schema = db.studentSchema();&#10;        auto action = toLowerCopy(actionRaw);&#10;        if (action == &quot;create&quot;)&#10;        {&#10;            auto result = handleCreate(payload, schema,&#10;                [&amp;](int id) { return db.createStudent(id); },&#10;                [&amp;](int id) { db.deleteStudent(id); },&#10;                [&amp;]() { return db.allocateStudentId(); });&#10;            if (result.at(&quot;count&quot;).get&lt;size_t&gt;() &gt; 0)&#10;            {&#10;                db.commit();&#10;            }&#10;            return result;&#10;        }&#10;        if (action == &quot;query&quot;)&#10;        {&#10;            return handleQuery(payload, db.students(), schema);&#10;        }&#10;        if (action == &quot;update&quot;)&#10;        {&#10;            auto result = handleUpdate(payload, schema, [&amp;](int id) { return db.getStudent(id); });&#10;            db.commit();&#10;            return result;&#10;        }&#10;        if (action == &quot;delete&quot;)&#10;        {&#10;            auto result = handleDelete(payload, &quot;student&quot;, [&amp;](int id) { return db.deleteStudent(id); });&#10;            db.commit();&#10;            return result;&#10;        }&#10;        throw ApiError(400, &quot;Unsupported student action: &quot; + actionRaw);&#10;    }&#10;&#10;    json handleGroup(const std::string&amp; actionRaw, const json&amp; payload, SSDB::SecScoreDB&amp; db, std::mutex&amp; mutex)&#10;    {&#10;        std::scoped_lock lock(mutex);&#10;        const auto&amp; schema = db.groupSchema();&#10;        auto action = toLowerCopy(actionRaw);&#10;        if (action == &quot;create&quot;)&#10;        {&#10;            auto result = handleCreate(payload, schema,&#10;                [&amp;](int id) { return db.createGroup(id); },&#10;                [&amp;](int id) { db.deleteGroup(id); },&#10;                [&amp;]() { return db.allocateGroupId(); });&#10;            if (result.at(&quot;count&quot;).get&lt;size_t&gt;() &gt; 0)&#10;            {&#10;                db.commit();&#10;            }&#10;            return result;&#10;        }&#10;        if (action == &quot;query&quot;)&#10;        {&#10;            return handleQuery(payload, db.groups(), schema);&#10;        }&#10;        if (action == &quot;update&quot;)&#10;        {&#10;            auto result = handleUpdate(payload, schema, [&amp;](int id) { return db.getGroup(id); });&#10;            db.commit();&#10;            return result;&#10;        }&#10;        if (action == &quot;delete&quot;)&#10;        {&#10;            auto result = handleDelete(payload, &quot;group&quot;, [&amp;](int id) { return db.deleteGroup(id); });&#10;            db.commit();&#10;            return result;&#10;        }&#10;        throw ApiError(400, &quot;Unsupported group action: &quot; + actionRaw);&#10;    }&#10;&#10;    json handleEvent(const std::string&amp; actionRaw, const json&amp; payload, SSDB::SecScoreDB&amp; db, std::mutex&amp; mutex)&#10;    {&#10;        auto action = toLowerCopy(actionRaw);&#10;        if (action == &quot;create&quot;)&#10;        {&#10;            if (!payload.contains(&quot;id&quot;) || !payload.at(&quot;id&quot;).is_null())&#10;            {&#10;                throw ApiError(422, &quot;event.id must be null for auto generation.&quot;);&#10;            }&#10;            if (!payload.contains(&quot;type&quot;) || !payload.at(&quot;type&quot;).is_number_integer())&#10;            {&#10;                throw ApiError(400, &quot;event.type must be integer.&quot;);&#10;            }&#10;            if (!payload.contains(&quot;ref_id&quot;) || !payload.at(&quot;ref_id&quot;).is_number_integer())&#10;            {&#10;                throw ApiError(400, &quot;event.ref_id must be integer.&quot;);&#10;            }&#10;            if (!payload.contains(&quot;desc&quot;) || !payload.at(&quot;desc&quot;).is_string())&#10;            {&#10;                throw ApiError(400, &quot;event.desc must be string.&quot;);&#10;            }&#10;            if (!payload.contains(&quot;val_prev&quot;) || !payload.contains(&quot;val_curr&quot;))&#10;            {&#10;                throw ApiError(400, &quot;event.val_prev and event.val_curr are required.&quot;);&#10;            }&#10;            double prev = requireNumber(payload.at(&quot;val_prev&quot;), &quot;val_prev&quot;);&#10;            double curr = requireNumber(payload.at(&quot;val_curr&quot;), &quot;val_curr&quot;);&#10;&#10;            SSDB::Event evt;&#10;            evt.SetId(SSDB::INVALID_ID);&#10;            evt.SetEventType(parseEventType(payload.at(&quot;type&quot;).get&lt;int&gt;()));&#10;            evt.SetOperatingObject(payload.at(&quot;ref_id&quot;).get&lt;int&gt;());&#10;            evt.SetReason(payload.at(&quot;desc&quot;).get&lt;std::string&gt;());&#10;            evt.SetDeltaScore(static_cast&lt;int&gt;(std::llround(curr - prev)));&#10;&#10;            auto timestamp = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(evt.GetEventTime().time_since_epoch()).count();&#10;&#10;            std::scoped_lock lock(mutex);&#10;            int id = db.addEvent(evt);&#10;            db.commit();&#10;            return json{{&quot;id&quot;, id}, {&quot;timestamp&quot;, timestamp}};&#10;        }&#10;        if (action == &quot;update&quot;)&#10;        {&#10;            if (!payload.contains(&quot;id&quot;) || !payload.at(&quot;id&quot;).is_number_integer())&#10;            {&#10;                throw ApiError(400, &quot;event.id must be integer.&quot;);&#10;            }&#10;            if (!payload.contains(&quot;erased&quot;) || !payload.at(&quot;erased&quot;).is_boolean())&#10;            {&#10;                throw ApiError(400, &quot;event.erased must be boolean.&quot;);&#10;            }&#10;            std::scoped_lock lock(mutex);&#10;            int id = payload.at(&quot;id&quot;).get&lt;int&gt;();&#10;            db.setEventErased(id, payload.at(&quot;erased&quot;).get&lt;bool&gt;());&#10;            db.commit();&#10;            return json{{&quot;id&quot;, id}, {&quot;erased&quot;, payload.at(&quot;erased&quot;).get&lt;bool&gt;()}};&#10;        }&#10;        throw ApiError(400, &quot;Unsupported event action: &quot; + actionRaw);&#10;    }&#10;&#10;    json dispatch(const std::string&amp; categoryRaw, const std::string&amp; action, const json&amp; payload, SSDB::SecScoreDB&amp; db, std::mutex&amp; mutex)&#10;    {&#10;        auto category = toLowerCopy(categoryRaw);&#10;        if (category == &quot;system&quot;)&#10;        {&#10;            return handleSystem(action, payload, db, mutex);&#10;        }&#10;        if (category == &quot;student&quot;)&#10;        {&#10;            return handleStudent(action, payload, db, mutex);&#10;        }&#10;        if (category == &quot;group&quot;)&#10;        {&#10;            return handleGroup(action, payload, db, mutex);&#10;        }&#10;        if (category == &quot;event&quot;)&#10;        {&#10;            return handleEvent(action, payload, db, mutex);&#10;        }&#10;        throw ApiError(400, &quot;Unsupported category: &quot; + categoryRaw);&#10;    }&#10;}&#10;&#10;int main(int argc, char** argv)&#10;{&#10;    try&#10;    {&#10;        uint16_t port = 8765;&#10;        std::filesystem::path dbPath = std::filesystem::current_path() / &quot;data&quot;;&#10;&#10;        for (int i = 1; i &lt; argc; ++i)&#10;        {&#10;            std::string arg = argv[i];&#10;            if (arg == &quot;--port&quot; &amp;&amp; i + 1 &lt; argc)&#10;            {&#10;                port = static_cast&lt;uint16_t&gt;(std::stoi(argv[++i]));&#10;                continue;&#10;            }&#10;            if (arg == &quot;--db&quot; &amp;&amp; i + 1 &lt; argc)&#10;            {&#10;                dbPath = argv[++i];&#10;                continue;&#10;            }&#10;            std::cerr &lt;&lt; &quot;Unknown argument: &quot; &lt;&lt; arg &lt;&lt; &quot;\n&quot;;&#10;            std::cerr &lt;&lt; &quot;Usage: SecScoreDB-Websockets [--port &lt;number&gt;] [--db &lt;path&gt;]&quot; &lt;&lt; std::endl;&#10;            return 1;&#10;        }&#10;&#10;        ix::initNetSystem();&#10;        SSDB::SecScoreDB database(dbPath);&#10;        std::mutex dbMutex;&#10;&#10;        ix::WebSocketServer server(port);&#10;        server.setOnConnection([&amp;](const ix::WebSocketConnectionPtr&amp; connection)&#10;        {&#10;            connection-&gt;setOnMessageCallback([&amp;, connection](const ix::WebSocketMessagePtr&amp; msg)&#10;            {&#10;                if (msg-&gt;type != ix::WebSocketMessageType::Message)&#10;                {&#10;                    return;&#10;                }&#10;&#10;                std::string seq;&#10;                try&#10;                {&#10;                    auto request = json::parse(msg-&gt;str);&#10;                    if (!request.contains(&quot;seq&quot;) || !request.at(&quot;seq&quot;).is_string())&#10;                    {&#10;                        throw ApiError(400, &quot;seq is required and must be string.&quot;);&#10;                    }&#10;                    seq = request.at(&quot;seq&quot;).get&lt;std::string&gt;();&#10;                    if (!request.contains(&quot;category&quot;) || !request.at(&quot;category&quot;).is_string())&#10;                    {&#10;                        throw ApiError(400, &quot;category is required.&quot;);&#10;                    }&#10;                    if (!request.contains(&quot;action&quot;) || !request.at(&quot;action&quot;).is_string())&#10;                    {&#10;                        throw ApiError(400, &quot;action is required.&quot;);&#10;                    }&#10;                    if (!request.contains(&quot;payload&quot;))&#10;                    {&#10;                        throw ApiError(400, &quot;payload is required.&quot;);&#10;                    }&#10;                    const auto&amp; payload = request.at(&quot;payload&quot;);&#10;                    if (!payload.is_object())&#10;                    {&#10;                        throw ApiError(400, &quot;payload must be an object.&quot;);&#10;                    }&#10;&#10;                    auto data = dispatch(request.at(&quot;category&quot;).get&lt;std::string&gt;(), request.at(&quot;action&quot;).get&lt;std::string&gt;(), payload, database, dbMutex);&#10;                    connection-&gt;send(makeOkResponse(seq, data).dump());&#10;                }&#10;                catch (const ApiError&amp; err)&#10;                {&#10;                    connection-&gt;send(makeErrorResponse(seq, err.code, err.what()).dump());&#10;                }&#10;                catch (const json::exception&amp; err)&#10;                {&#10;                    connection-&gt;send(makeErrorResponse(seq, 400, std::string(&quot;Invalid JSON: &quot;) + err.what()).dump());&#10;                }&#10;                catch (const std::exception&amp; err)&#10;                {&#10;                    connection-&gt;send(makeErrorResponse(seq, 500, err.what()).dump());&#10;                }&#10;            });&#10;        });&#10;&#10;        if (!server.listen().first)&#10;        {&#10;            std::cerr &lt;&lt; &quot;Failed to listen on port &quot; &lt;&lt; port &lt;&lt; std::endl;&#10;            return 1;&#10;        }&#10;        server.start();&#10;        std::cout &lt;&lt; &quot;SecScoreDB WebSocket server listening on ws://0.0.0.0:&quot; &lt;&lt; port&#10;                  &lt;&lt; &quot; using data directory '&quot; &lt;&lt; dbPath.string() &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;&#10;        server.wait();&#10;        ix::uninitNetSystem();&#10;    }&#10;    catch (const std::exception&amp; err)&#10;    {&#10;        std::cerr &lt;&lt; &quot;Fatal error: &quot; &lt;&lt; err.what() &lt;&lt; std::endl;&#10;        return 1;&#10;    }&#10;    return 0;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>